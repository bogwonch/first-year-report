\documentclass[report.tex]{subfiles}
\begin{document}

\section{Proposal}

\subsection{Work Done In First Year}

During the first year of my studies we have focussed on developing an
authorization logic that can express the security policies a user might have for
their smart phone; in particular the policies when the user is installing apps.
We have considered what kinds of policies and trust
relationships a user might wish to express and shown how they can be expressed
in the language.

To do this we initially looked at a variety of authorization logics including
BLF\cite{Whitehead:2004bu} and Binder\cite{DeTreville:2002ff} before settling on
SecPAL as it was both simple, extensible and readable.  SecPAL's decentralized
nature was felt to be ideal for describing a mobile-device and app-store
ecosystem as there isn't a single authority making decisions about what can and
cannot be installed onto a device.  

When considering the policies we wanted to allow users to delegate decisions to
experts who might be third party certification services or static analysis
services running on a remote server or on the device itself.  There should be
the ability to use digital evidence\cite{Stark:2009uc} as a means of increasing
trust in an external tool as this might allow proof checking to be done with
less strain on a mobile's battery.  We also wanted to have a clear separation
between the checking of the user's security policy for the device (the
\emph{device policy}) and the policies any tool was checking for an app (the
\emph{application policy}).  This means that any analysis tool needn't use the
same logic for checking the application policy, as the device uses for checking
it's own policy.  In the security policy static analysis tools are treated as
oracles: they can utter statements about their inputs but we do not know (or
care) how they came to these conclusions.

To do this we extended SecPAL with two new predicates.  The \emph{meets}
predicate is used to state that some entity believes an app meets an application
policy.  For instance if Alice believed that the \emph{Angry-Birds} app met her
policy to not leak information about her then we would have the statement:

\begin{lstlisting}[language=SecPAL]
Alice says AngryBirds meets NoInfoLeaks.
\end{lstlisting}

To express the notions of proof carrying code\cite{Necula:1996tr} and digital
evidence we want to say that some evidence \emph{shows} a policy is met.  To do
this we introduce the \emph{shows-meets} predicate (whose notation we sugar
somewhat).  As an example consider again Alice who this time has managed to get
some digital evidence to show Angry-Birds won't leak her information.

\begin{lstlisting}[language=SecPAL]
Alice says Evidence shows AngryBirds meets NoInfoLeaks.
\end{lstlisting}

\subsection{Alice Installs An App}

To provide a better idea of the logic might be used we will describe a story
where a user is trying to install an app on their mobile phone.  This example is
built from our work that was presented as a paper at the ESSoS Doctoral
Symposium\cite{Hallett:2014un} and as a poster at the FMATS workshop.

Suppose Alice has a smart phone.  Alice has a security policy that says:

\begin{quote}
    ``No app installed on my phone will send my location to an advertiser, and I
      wont install anything that Google says is malware.''
\end{quote}

Alice trusts Google to decide whether something is malware or not (or at at
least recommend an anti-virus vendor who can be trusted), and she trusts the
\emph{NLLTool} to decide whether an app will leak her location
data.  Alice has heard about digital evidence and is happy that if an app can
come with a proof of it meeting a policy then she will believe it.

She translates her policy into SecPAL thus:

\begin{lstlisting}[language=SecPAL]
  Alice says app is-installable 
    if app meets NotMalware, 
       app meets NoLocationLeaks.

  Alice says Google can-say inf app meets NotMalware.
  Alice says NLLTool can-say 0 app meets NoLocationLeaks.

  anyone says app meets policy
    if evidence shows app meets policy.
\end{lstlisting}

Alice wishes to install Angry Birds. To do so she downloads the app from a
modified app store where apps come with statements about their security.  Alice
takes the statements from the store and builds her assertion context.  These
statements include a delegation from Google to say McAfee can be trusted to
decide whether an app is malware or not, as well as some statements from McAfee
and the NLLTool about the app itself. The full assertion context is shown in
Figure~\ref{secpal:exampleac}.

\begin{marginfigure}\label{secpal:exampleac}
\begin{lstlisting}[language=SecPAL]
  Alice says app is-installable 
    if app meets NotMalware, 
    app meets NoLocationLeaks.
  anyone says app meets policy 
    if evidence shows app meets policy.
  Alice says Google can-say inf 
    app meets NotMalware.
  Alice says NLLTool can-say 0 
    app meets NoLocationLeaks.
  Google says McAfee can-say 0 
    app meets NotMalware.
  McAfee says 
    AngryBirds meets NotMalware.
  NLLTool says ABProof shows 
    AngryBirds meets NoLocationLeaks.
\end{lstlisting}
\caption{The full assertion context used to evaluate Alice's query.}
\end{marginfigure}

Alice then uses SecPAL to decide whether or not the assertion context supports
the idea that \code{Alice says app is-installable.}

\subsection{Implementation}

To evaluate her security policy we implemented the SecPAL logic.
The implementation was done in the Haskell programming language and is around a
thousand lines of code plus five hundred lines of test cases (including
comments).

Whilst in the original SecPAL paper\cite{Becker:2010vh}
\citeauthor*{Becker:2010vh} describe an efficient implementation using Datalog;
this implementation uses a simpler goal-oriented \emph{brute-force} approach.
It was written in this way to quickly evaluate whether SecPAL is a good fit for
the problem, rather than to be an efficient production ready inference
engine\footnote{In fact it could never be used for this as most Android devices
  run using ARM processors which are poorly supported by Haskell compilers.}
That said it supports command history, dynamically loaded constraint-functions,
comes with syntax highlighting plugins for Vim, and has handled simple assertion
contexts with over a thousand statements: whilst it is not ideal it can happily serve as
a reference for a later efficient implementation.

\begin{figure*}\label{secpal:exampleproof}
  \begin{lstlisting}[basicstyle=\footnotesize\ttfamily,columns=flexible,mathescape]
AC, inf [app\AngryBirds] |= Alice says AngryBirds is-installable.
  AC, inf [app\AngryBirds] |= Alice says AngryBirds meets NotMalware.
    AC, inf [app\AngryBirds] |= Alice says Google can-say inf app meets NotMalware.
    -------------------------------------------------------------------------------
    AC, inf [app\AngryBirds] |= Google says AngryBirds meets NotMalware.
      AC, inf [app\AngryBirds] |= Google says McAfee can-say 0 app meets NotMalware.
      ------------------------------------------------------------------------------
      AC, 0 |= McAfee says AngryBirds meets NotMalware.
        AC, 0 |= True
        -------------
  AC, inf [app\AngryBirds] |= Alice says AngryBirds meets NoLocationLeaks.
    AC, inf [app\AngryBirds] |= Alice says NLLTool can-say 0 app meets NoLocationLeaks.
    -----------------------------------------------------------------------------------
    AC, 0 [anyone\NLLTool, ...] |= NLLTool says AngryBirds meets NoLocationLeaks.
      AC, 0 [evidence\ABProof] |= NLLTool says ABProof shows AngryBirds meets NoLocationLeaks.
        AC, 0 |= True
        -------------
      AC, 0 |= True
      -------------
  AC, inf |= True
  ---------------
  \end{lstlisting}
  \caption{Proof output by the SecPAL tool when evaluating Alice's query.  The
    proof is presented as an inverted inference tree where indented statements
    are the proofs for each condition of the unindented line above.  Underlining
    indicates something is known to be true as it either exists in the assertion
    context or is true in itself. Variable substitutions are shown in brackets
    to aid debugging}
\end{figure*}

\subsection{Second year}


\subsection{Third year}



\end{document}

